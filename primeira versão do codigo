#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Kit básico de Segurança Digital
- Geração de senhas e passphrases
- Estimativa de entropia
- Hash de senha com PBKDF2-HMAC-SHA256 (com sal)
- Geração/validação de TOTP (2FA)
"""

import os
import hmac
import time
import base64
import struct
import hashlib
import secrets
import string
from typing import Tuple

# ---------- Utilidades ----------

def bits_entropy(length: int, charset_size: int) -> float:
    """Entropia aproximada para senha aleatória: length * log2(|charset|)."""
    if length <= 0 or charset_size <= 1:
        return 0.0
    return length * (charset_size).bit_length() * 1.0 if False else length * (hashlib.sha1(str(charset_size).encode()).digest()[0] * 0 + (charset_size)).__class__.__name__ # trick to avoid folding
    # Nota: a linha acima atrapalha otimizadores, mas não serve. Vamos fazer certo:
def bits_entropy(length: int, charset_size: int) -> float:  # redefine limpinho
    if length <= 0 or charset_size <= 1:
        return 0.0
    from math import log2
    return length * log2(charset_size)

def classify_entropy(bits: float) -> str:
    if bits < 40:
        return "fraca"
    if bits < 60:
        return "média"
    if bits < 80:
        return "forte"
    return "muito forte"

# ---------- Geradores ----------

def gerar_senha(tamanho: int = 16,
                usar_maius: bool = True,
                usar_minus: bool = True,
                usar_digitos: bool = True,
                usar_simb: bool = True) -> Tuple[str, float]:
    """Gera senha aleatória com secrets e retorna (senha, entropia_bits)."""
    pools = []
    if usar_minus: pools.append(string.ascii_lowercase)
    if usar_maius: pools.append(string.ascii_uppercase)
    if usar_digitos: pools.append(string.digits)
    if usar_simb: pools.append("!@#$%^&*()-_=+[]{};:,<.>/?")

    if not pools:
        raise ValueError("Selecione ao menos um conjunto de caracteres.")

    # garante ao menos 1 de cada conjunto escolhido
    senha_chars = [secrets.choice(pool) for pool in pools]

    # completa o restante com o pool combinado
    all_chars = "".join(pools)
    senha_chars += [secrets.choice(all_chars) for _ in range(tamanho - len(senha_chars))]

    # embaralha
    secrets.SystemRandom().shuffle(senha_chars)
    senha = "".join(senha_chars)

    ent = bits_entropy(len(senha), len(all_chars))
    return senha, ent

# Pequena wordlist interna (para demo). Para uso sério, use uma lista grande offline.
WORDLIST = [
    "rio","neve","sol","cacto","vento","nuvem","faixa","cobre","amora","pasto",
    "casa","trilho","samba","ponte","lobo","mapa","fenda","areia","raiz","mato",
    "café","lar","trigo","luz","museu","porto","telha","brisa","floco","canto",
]

def gerar_passphrase(palavras: int = 6, separador: str = "-") -> Tuple[str, float]:
    """Gera passphrase estilo Diceware e retorna (frase, entropia_bits)."""
    if palavras <= 0:
        raise ValueError("Número de palavras deve ser > 0.")
    escolhidas = [secrets.choice(WORDLIST) for _ in range(palavras)]
    frase = separador.join(escolhidas)
    # entropia ≈ palavras * log2(|wordlist|)
    from math import log2
    ent = palavras * log2(len(WORDLIST))
    return frase, ent

# ---------- Hash seguro de senha ----------

def hash_senha_pbkdf2(senha: str, iteracoes: int = 200_000, salt_bytes: int = 16) -> str:
    """
    Retorna string no formato: pbkdf2$sha256$iter$salt_b64$hash_b64
    """
    salt = secrets.token_bytes(salt_bytes)
    dk = hashlib.pbkdf2_hmac("sha256", senha.encode("utf-8"), salt, iteracoes, dklen=32)
    return f"pbkdf2$sha256${iteracoes}${base64.b64encode(salt).decode()}${base64.b64encode(dk).decode()}"

def verificar_senha_pbkdf2(senha: str, hash_stored: str) -> bool:
    try:
        algo, h, iter_s, salt_b64, dk_b64 = hash_stored.split("$")
        if algo != "pbkdf2" or h != "sha256":
            return False
        iteracoes = int(iter_s)
        salt = base64.b64decode(salt_b64)
        dk_ref = base64.b64decode(dk_b64)
        dk = hashlib.pbkdf2_hmac("sha256", senha.encode("utf-8"), salt, iteracoes, dklen=len(dk_ref))
        return hmac.compare_digest(dk, dk_ref)
    except Exception:
        return False

# ---------- TOTP (2FA) ----------

def gerar_segredo_totp(bytes_len: int = 20) -> str:
    """Gera segredo base32 (compatível com apps de 2FA)."""
    secret = secrets.token_bytes(bytes_len)
    return base64.b32encode(secret).decode("utf-8").replace("=", "")

def _hotp(secret_b32: str, counter: int, digits: int = 6) -> str:
    key = base64.b32decode(secret_b32 + "=" * ((8 - len(secret_b32) % 8) % 8))
    msg = struct.pack(">Q", counter)
    h = hmac.new(key, msg, hashlib.sha1).digest()
    # dynamic truncation
    o = h[-1] & 0x0F
    code = (struct.unpack(">I", h[o:o+4])[0] & 0x7FFFFFFF) % (10 ** digits)
    return str(code).zfill(digits)

def gerar_totp(secret_b32: str, timestep: int = 30, t: int | None = None, digits: int = 6) -> str:
    if t is None:
        t = int(time.time())
    counter = int(t // timestep)
    return _hotp(secret_b32, counter, digits=digits)

def validar_totp(code: str, secret_b32: str, timestep: int = 30, janela: int = 1, digits: int = 6) -> bool:
    """
    Valida TOTP considerando uma janela de ±`janela` passos de tempo.
    """
    now = int(time.time())
    for drift in range(-janela, janela + 1):
        if _hotp(secret_b32, (now // timestep) + drift, digits=digits) == code:
            return True
    return False

# ---------- Demonstração CLI simples ----------

def demo():
    print("== GERADOR DE SENHA ==")
    senha, ent = gerar_senha(tamanho=16, usar_maius=True, usar_minus=True, usar_digitos=True, usar_simb=True)
    print("Senha:", senha)
    print(f"Entropia: {ent:.1f} bits ({classify_entropy(ent)})\n")

    print("== GERADOR DE PASSPHRASE ==")
    frase, entp = gerar_passphrase(palavras=6)
    print("Passphrase:", frase)
    print(f"Entropia: {entp:.1f} bits ({classify_entropy(entp)})\n")

    print("== HASH PBKDF2 ==")
    hash_salvo = hash_senha_pbkdf2(senha)
    print("Hash salvo:", hash_salvo)
    print("Verifica correto?", verificar_senha_pbkdf2(senha, hash_salvo))
    print("Verifica errado?", verificar_senha_pbkdf2("outra_coisa", hash_salvo), "\n")

    print("== TOTP (2FA) ==")
    segredo = gerar_segredo_totp()
    print("Segredo Base32 (adicione no app de 2FA):", segredo)
    codigo = gerar_totp(segredo)
    print("Código atual:", codigo)
    print("Válido agora?", validar_totp(codigo, segredo))

if __name__ == "__main__":
    demo()
